import {
  WebGLRenderer,
  Scene,
  Color,
  PerspectiveCamera,
  Clock,
  ACESFilmicToneMapping,
  AmbientLight,
  PointLight,
  HemisphereLight,
  DirectionalLight,
  CubeCamera,
  WebGLCubeRenderTarget,
  BoxGeometry,
  Mesh,
  MeshBasicMaterial,
  sRGBEncoding,
  SphereGeometry,
  MeshStandardMaterial,
  DirectionalLightHelper,
} from 'three'

import { rand } from '@ThreeSketch/utils/rand'
import { Vector3 } from '@ThreeSketch/utils/vector3'

// ODE stands for Ordinary differential equation
// Coord is generated by Explicit Euler Method
class ODEMovingObject {
  constructor(dx, dy, dz, x, y, z) {
    this.dx = dx
    this.dy = dy
    this.dz = dz
    this.x = x
    this.y = y
    this.z = z
    this.w_speed = rand(1, 1)
  }

  // apply=true if you want to update new coordinates for object
  updatePos(dt, apply = false) {
    dt = this.w_speed * dt
    if (apply) {
      this.x = this.x + this.dx(this.x, this.y, this.z, dt)
      this.y = this.y + this.dy(this.x, this.y, this.z, dt)
      this.z = this.z + this.dz(this.x, this.y, this.z, dt)
      return { x: this.x, y: this.y, z: this.z }
    }
    return {
      x: this.x + this.dx(this.x, this.y, this.z, dt),
      y: this.y + this.dy(this.x, this.y, this.z, dt),
      z: this.z + this.dz(this.x, this.y, this.z, dt),
    }
  }

  getPos() {
    return { x: this.x, y: this.y, z: this.z }
  }
}

export function genODEMovingObjects(numMovingObjects) {
  const a = 0.44,
    b = 1.1,
    c = 1
  // ODEs
  let dx = (x, y, z, dt) => y * dt
  let dy = (x, y, z, dt) => z * dt
  let dz = (x, y, z, dt) => (-c * x - b * y - a * z + x * x) * dt

  const res = []
  // init random particles in cube (-0.2, -0.2, -0.2) to (0.2, 0.2, 0.2)
  for (let i = 0; i < numMovingObjects; i++) {
    res.push(
      new ODEMovingObject(
        dx,
        dy,
        dz,
        rand(-0.2, 0.2),
        rand(-0.2, 0.2),
        rand(-0.2, 0.2),
      ),
    )
  }
  return res
}

export class ODEObjectSystem {
  constructor() {}

  init(numMovingObjects) {
    this.numMovingObjects = numMovingObjects
    this.movingObjects = genODEMovingObjects(numMovingObjects)
    this.startTime = Date.now()
    this.lastTime = Date.now()
  }

  update() {
    const curTime = Date.now()
    for (let i = 0; i < this.numMovingObjects; i++) {
      let dt = (curTime - this.lastTime) / 500
      if (dt > 0.02) dt = 0.02
      this.movingObjects[i].updatePos(dt, true)
    }

    this.lastTime = curTime
  }
}

const MIN_DIS = 0.0003
const EPSILON = 1e-9
const G = 6.6743e-11

export class GravityMovingSystem {
  constructor() {}

  init(numMovingObjects) {
    this.numMovingObjects = numMovingObjects
    this.movingObjects = []
    for (let i = 0; i < numMovingObjects; i++) {
      let p = Vector3.rand(-1, 1)
      let v = Vector3.rand(-0.1, 0.1)
      let m = rand(1e7, 5e7)
      if (i == 0) (m = 1e10), (p = Vector3.rand(0, 0)), (v = Vector3.rand(0, 0))
      this.movingObjects.push(new GravityMovingObject(p, v, m))
    }
    this.startTime = Date.now()
    this.lastTime = Date.now()
  }

  // Get gravity force of b acting on a
  getGravityForce(a, b) {
    // f = ab * m_a * m_b / |ab|^3 where ab = p_a - p_b
    let vec_ab = Vector3.sub(b.p, a.p)
    return Vector3.mul(
      vec_ab,
      (G * a.m * b.m) / (Math.pow(vec_ab.length(), 3) + EPSILON),
    )
  }

  update() {
    // calculate gravitational force
    for (let i = 1; i < this.numMovingObjects; i++) {
      let vec_f = new Vector3(0, 0, 0)
      for (let j = 0; j < this.numMovingObjects; j++) {
        if (i == j) continue
        vec_f.add(
          this.getGravityForce(this.movingObjects[i], this.movingObjects[j]),
        )
      }
      this.movingObjects[i].setForce(vec_f)
    }

    // timeleap system
    const curTime = Date.now()
    for (let i = 0; i < this.numMovingObjects; i++) {
      let dt = (curTime - this.lastTime) / 500
      if (dt > 0.02) dt = 0.02
      this.movingObjects[i].update(dt)
    }

    this.lastTime = curTime
  }
}

class GravityMovingObject {
  constructor(p, v, m) {
    this.p = p
    this.v = v
    this.a = Vector3.zero()
    this.m = m
    this.deleted = false
  }

  setForce(f) {
    // a = f/m
    this.a = Vector3.div(f, this.m)
  }

  update(dt) {
    // dv = a * dt
    // dp = v * dt
    // a = 0
    this.v.add(Vector3.mul(this.a, dt))
    this.p.add(Vector3.mul(this.v, dt))
  }

  getPos() {
    return this.p
  }
}
